{"version":3,"file":"signals-core.min.js","sources":["../src/index.ts"],"sourcesContent":["// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n//#region Signal\n\n/**\n * The base class for plain and computed signals.\n */\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T, options?: SignalOptions<T>);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\t/** @internal */\n\t_watched?(this: Signal<T>): void;\n\n\t/** @internal */\n\t_unwatched?(this: Signal<T>): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tname?: string;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\nexport interface SignalOptions<T = any> {\n\twatched?: (this: Signal<T>) => void;\n\tunwatched?: (this: Signal<T>) => void;\n\tname?: string;\n}\n\n/** @internal */\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\nfunction Signal(this: Signal, value?: unknown, options?: SignalOptions) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tconst targets = this._targets;\n\tif (targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = targets;\n\t\tthis._targets = node;\n\n\t\tif (targets !== undefined) {\n\t\t\ttargets._prevTarget = node;\n\t\t} else {\n\t\t\tuntracked(() => {\n\t\t\t\tthis._watched?.call(this);\n\t\t\t});\n\t\t}\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t\tif (next === undefined) {\n\t\t\t\tuntracked(() => {\n\t\t\t\t\tthis._unwatched?.call(this);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(\n\t\t() => {\n\t\t\tconst value = this.value;\n\t\t\tconst prevContext = evalContext;\n\t\t\tevalContext = undefined;\n\t\t\ttry {\n\t\t\t\tfn(value);\n\t\t\t} finally {\n\t\t\t\tevalContext = prevContext;\n\t\t\t}\n\t\t},\n\t\t{ name: \"sub\" }\n\t);\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T, options?: SignalOptions<T>): Signal<T> {\n\treturn new Signal(value, options);\n}\n\n//#endregion Signal\n\n//#region Computed\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tif (\n\t\t\t// If the dependency has definitely been updated since its version number\n\t\t\t// was observed, then we need to recompute. This first check is not strictly\n\t\t\t// necessary for correctness, but allows us to skip the refresh call if the\n\t\t\t// dependency has already been updated.\n\t\t\tnode._source._version !== node._version ||\n\t\t\t// Refresh the dependency. If there's something blocking the refresh (e.g. a\n\t\t\t// dependency cycle), then we need to recompute.\n\t\t\t!node._source._refresh() ||\n\t\t\t// If the dependency got a new version after the refresh, then we need to recompute.\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head: Node | undefined = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\n/**\n * The base class for computed signals.\n */\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T, options?: SignalOptions<T>);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\n/** @internal */\nfunction Computed(this: Computed, fn: () => unknown, options?: SignalOptions) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(\n\tfn: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\treturn new Computed(fn, options);\n}\n\n//#endregion Computed\n\n//#region Effect\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn =\n\t| ((this: { dispose: () => void }) => void | (() => void))\n\t| (() => void | (() => void));\n\n/**\n * The base class for reactive effects.\n */\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\t_debugCallback?: () => void;\n\tname?: string;\n\n\tconstructor(fn: EffectFn, options?: EffectOptions);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n\tdispose(): void;\n}\n\nexport interface EffectOptions {\n\tname?: string;\n}\n\nlet capturedEffects: Effect[] | undefined;\n\n/** @internal */\nfunction Effect(this: Effect, fn: EffectFn, options?: EffectOptions) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n\tthis.name = options?.name;\n\n\tif (capturedEffects) {\n\t\tcapturedEffects.push(this);\n\t}\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nEffect.prototype.dispose = function () {\n\tthis._dispose();\n};\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn, options?: EffectOptions): () => void {\n\tconst effect = new Effect(fn, options);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\tconst dispose = effect._dispose.bind(effect);\n\t(dispose as any)[Symbol.dispose] = dispose;\n\treturn dispose as any;\n}\n\n//#endregion Effect\n\n//#region Action\n\nfunction action<TArgs extends unknown[], TReturn>(\n\tfn: (...args: TArgs) => TReturn\n): (...args: TArgs) => TReturn {\n\treturn function actionWrapper(this: unknown, ...args: TArgs) {\n\t\treturn batch(() => untracked(() => fn.apply(this, args)));\n\t};\n}\n\n//#endregion Action\n\n//#region createModel\n\n/** Models should only contain signals, actions, and nested objects containing only signals and actions. */\ntype ValidateModel<TModel> = {\n\t[Key in keyof TModel]: TModel[Key] extends ReadonlySignal<unknown>\n\t\t? TModel[Key]\n\t\t: TModel[Key] extends (...args: any[]) => any\n\t\t\t? TModel[Key]\n\t\t\t: TModel[Key] extends object\n\t\t\t\t? ValidateModel<TModel[Key]>\n\t\t\t\t: `Property ${Key extends string ? `'${Key}' ` : \"\"}is not a Signal, Action, or an object that contains only Signals and Actions.`;\n};\n\nexport type Model<TModel> = ValidateModel<TModel> & Disposable;\n\nexport type ModelFactory<TModel, TFactoryArgs extends any[] = []> = (\n\t...args: TFactoryArgs\n) => ValidateModel<TModel>;\nexport type ModelConstructor<TModel, TFactoryArgs extends any[] = []> = new (\n\t...args: TFactoryArgs\n) => Model<TModel>;\n\n/**\n * The public types for ModelConstructor require using `new` to help\n * disambiguate the function passed into `createModel` and the returned\n * constructor function. It is easier to say that `createModel` accepts\n * a factory and returns a class, then to say it accepts a factory and\n * returns a factory. In other words, this example:\n *\n * ```ts\n * const PersonModel = createModel((name: string) => ({ ... }));\n * const person = new PersonModel(\"John\");\n * ```\n *\n * is easier to understand than this example:\n *\n * ```ts\n * const createPerson = createModel((name: string) => ({ ... }));\n * const person = createPerson(\"John\");\n * ```\n *\n * However, internally we implement `createModel` to return a function\n * that can be called without `new` for simplicity. To bridge the gap\n * between the public types and the internal implementation, we define\n * this internal interface that extends the public interface but also\n * allows calling without `new`.\n *\n * This pattern is used by the Preact & React adapters to make instantiating\n * a model or a function that returns a model easier.\n *\n * @internal\n */\ninterface InternalModelConstructor<TModel, TFactoryArgs extends any[]>\n\textends ModelConstructor<TModel, TFactoryArgs> {\n\t(...args: TFactoryArgs): Model<TModel>;\n}\n\nfunction startCapturingEffects(): () => Effect[] | undefined {\n\tlet prevCapturedEffects = capturedEffects;\n\tcapturedEffects = [];\n\n\treturn function stopCapturingEffects() {\n\t\tlet modelEffects = capturedEffects;\n\t\tif (capturedEffects && prevCapturedEffects) {\n\t\t\tprevCapturedEffects = prevCapturedEffects.concat(capturedEffects);\n\t\t}\n\n\t\tcapturedEffects = prevCapturedEffects;\n\n\t\treturn modelEffects;\n\t};\n}\n\nfunction createModel<TModel, TFactoryArgs extends any[] = []>(\n\tmodelFactory: ModelFactory<TModel, TFactoryArgs>\n): ModelConstructor<TModel, TFactoryArgs> {\n\treturn function SignalModel(...args: TFactoryArgs): Model<TModel> {\n\t\tlet modelEffects: Effect[] | undefined;\n\t\tlet model: Model<TModel>;\n\n\t\tconst stopCapturingEffects = startCapturingEffects();\n\t\ttry {\n\t\t\tmodel = modelFactory(...args) as Model<TModel>;\n\t\t} catch (err) {\n\t\t\t// Drop any captured effects on error. Errors from nested models will bubble\n\t\t\t// up here and recursively reset `capturedEffects` to `undefined` preventing\n\t\t\t// any captured effects from leaking\n\t\t\tcapturedEffects = undefined;\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tmodelEffects = stopCapturingEffects();\n\t\t}\n\n\t\tfor (const key in model) {\n\t\t\t// @ts-expect-error TypeScript can't infer that model[key] is a valid here\n\t\t\tif (typeof model[key] === \"function\") {\n\t\t\t\t// @ts-expect-error TypeScript can't infer that model[key] is a valid function\n\t\t\t\t// to pass to action here\n\t\t\t\tmodel[key] = action(model[key]);\n\t\t\t}\n\t\t}\n\n\t\tmodel[Symbol.dispose] = action(function disposeModel() {\n\t\t\tif (modelEffects) {\n\t\t\t\tfor (let i = 0; i < modelEffects.length; i++) {\n\t\t\t\t\tmodelEffects[i].dispose();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmodelEffects = undefined;\n\t\t});\n\n\t\treturn model;\n\t} as InternalModelConstructor<TModel, TFactoryArgs>;\n}\n\n//#endregion createModel\n\nexport {\n\tcomputed,\n\teffect,\n\tbatch,\n\tuntracked,\n\taction,\n\tcreateModel,\n\tSignal,\n\tReadonlySignal,\n\tEffect,\n\tComputed,\n};\n"],"names":["g","f","exports","module","define","amd","globalThis","self","preactSignalsCore","this","BRAND_SYMBOL","Symbol","endBatch","batchDepth","error","hasError","undefined","batchedEffect","effect","batchIteration","next","_nextBatchedEffect","_flags","needsToRecompute","_callback","err","batch","fn","evalContext","untracked","prevContext","capturedEffects","globalVersion","addDependency","signal","node","_node","_target","_version","_source","_prevSource","_sources","_nextSource","_prevTarget","_nextTarget","_rollbackNode","_subscribe","Signal","value","options","_value","_targets","_watched","watched","_unwatched","unwatched","name","prototype","brand","_refresh","_this","targets","_this$_watched","call","_unsubscribe","_this2","prev","_this2$_unwatched","subscribe","_this3","valueOf","toString","toJSON","peek","Object","defineProperty","get","set","Error","_notify","target","prepareSources","rollbackNode","cleanupSources","head","Computed","_fn","_globalVersion","OUTDATED","cleanupEffect","cleanup","_cleanup","disposeEffect","endEffect","Effect","push","finish","_start","bind","_dispose","dispose","action","_arguments","arguments","_this4","apply","slice","startCapturingEffects","prevCapturedEffects","modelEffects","concat","computed","createModel","modelFactory","model","stopCapturingEffects","key","i","length"],"mappings":"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"}